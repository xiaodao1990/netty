### 线程模型的基本介绍
```text
1) 不同的线程模式，对程序的性能有很大影响，为了搞清Netty线程模型，我们来系统的讲解下各个线程的模式，最后看看Netty线程模型有什么优势。
2) 目前存在的线程模型有    
    传统阻塞I/O服务模型
    Reactor模式
3) 根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现
    单Reactor单线程
    单Reactor多线程
    主从Reactor多线程
4) Netty线程模式(Netty主要基于主从Reactor多线程模型做了一个的改进，其中主Reactor多线程模型有多个Reactor)
```

### 传统阻塞I/O服务模型
```text
工作原理图，见下方
    黄色的框表示对象，蓝色的框表示线程，白色的框表示方法(API)
模型特点
    1) 采用阻塞I/O模式获取输入的数据
    2) 每个连接都需要独立的线程完成数据的输入，业务的处理，数据的返回
问题分析    
    1) 当并发数很大，就会创建大量的线程，占用很大的系统资源。
    2) 连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read操作，造成线程资源的兰妃。
```
![avatar](./pic/004_netty.png)

### Reactor模式
```text
针对传统阻塞I/O服务模型的2个缺点，解决方案：    
    1) 基于I/O复用模型：多个连接共用一个阻塞对象，应用程序只需要对一个阻塞对象等待，无需阻塞等待
    所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。
    Reactor对应的叫法：a、反应器模式。b、分发者模式(Dispatcher)。c、通知者模式。
    2) 基于线程池服用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个
    线程可以处理多个连接的业务。
```
![avatar](./pic/005_netty.png)  
```text
I/O复用结合线程池，就是Reactor模式的基本设计思想
1) Reactor模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)
2) 服务器端程序处理传入的多个请求，并将他们呢同步分派给相应的处理线程。因此Reactor模式也叫Dispatcher模式
3) Reactor模式使用I/O复用监听事件，收到事件后，分发给某个线程(进程)，这里就是网络服务器高并发处理关键。
```
![avatar](./pic/006_netty.png)
```text
Reactor模式中的核心组成：
    1) Reactor：Reactor在一个单独线程中运行，负责监听和分发事件，分发给适当的处理程序来对I/O事件
    做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人。
    2) Handlers: 处理程序执行I/O事件要完成实际事件，类似于客户想要与之交谈的公司中的实际工作人员。
    Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作。
```
### Reactor 3种线程模型
#### 单Reactor单线程
![avatar](./pic/006_netty.png)
```text
工作原理见示意图：
    通过演示NIO群聊，说明
   
GroupChatServer 
    当前服务器的监听线程为：main
    。。。
    /127.0.0.1:64897上线了
    等待新时间。。。
    /127.0.0.1:64911上线了
    等待新时间。。。
    /127.0.0.1:64924上线了
    。。。
    from 客户端： 127.0.0.1:64897说：hello100                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
    当前服务器的处理线程为：main
    服务器转发消息中。。。
    。。。
    from 客户端： 127.0.0.1:64911说：hello200                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
    当前服务器的处理线程为：main
    服务器转发消息中。。。
    。。。
    from 客户端： 127.0.0.1:64924说：hello300                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
    当前服务器的处理线程为：main
    服务器转发消息中。。。
    
GroupChatClient 127.0.0.1:64897
    hello100

GroupChatClient 127.0.0.1:64911
    hello200
    
GroupChatClient 127.0.0.1:64924
    hello300
    
方案说明：    
    1) select是前面I/O复用模型介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求。
    2) Reactor对象通过select监听客户请求事件，收到事件后通过Dispatcher进行分发。
    3) 如果是建立连接的请求事件，则有Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接
    完成后的后续业务逻辑。
    4) 如果不是建立连接的事件，则Reactor会分发调用连接对应的Handler来响应。
    5) Handler会完成Read-->业务处理-->Send的完整业务流程。
    
结合实例：服务器端用一个线程通过多路复用搞定所有的 IO 操作（包括连接，读、写等），编码简单，清晰明了，
但是如果客户端连接数量较多，将无法支撑，前面的 NIO案例就属于这种模型。

```